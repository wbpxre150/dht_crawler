#include "discovered_nodes.h"
#include "dht_crawler.h"
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <arpa/inet.h>

/* Helper function to compare node IDs */
static int node_id_equal(const unsigned char *a, const unsigned char *b) {
    return memcmp(a, b, 20) == 0;
}

/* Helper function to compare socket addresses */
static int sockaddr_equal(const struct sockaddr *a, socklen_t a_len,
                         const struct sockaddr *b, socklen_t b_len) {
    if (a_len != b_len || a->sa_family != b->sa_family) {
        return 0;
    }

    if (a->sa_family == AF_INET) {
        const struct sockaddr_in *a4 = (const struct sockaddr_in *)a;
        const struct sockaddr_in *b4 = (const struct sockaddr_in *)b;
        return a4->sin_addr.s_addr == b4->sin_addr.s_addr &&
               a4->sin_port == b4->sin_port;
    } else if (a->sa_family == AF_INET6) {
        const struct sockaddr_in6 *a6 = (const struct sockaddr_in6 *)a;
        const struct sockaddr_in6 *b6 = (const struct sockaddr_in6 *)b;
        return memcmp(&a6->sin6_addr, &b6->sin6_addr, sizeof(a6->sin6_addr)) == 0 &&
               a6->sin6_port == b6->sin6_port;
    }

    return 0;
}

/* Check if node already exists in queue (caller must hold lock) */
static int is_duplicate(discovered_nodes_queue_t *queue,
                       const unsigned char *node_id,
                       const struct sockaddr *addr,
                       socklen_t addr_len) {
    size_t idx = queue->head;
    for (size_t i = 0; i < queue->count; i++) {
        discovered_node_t *node = &queue->nodes[idx];

        /* Check both node ID and address to catch ID changes */
        if (node_id_equal(node->node_id, node_id) ||
            sockaddr_equal((struct sockaddr *)&node->addr, node->addr_len, addr, addr_len)) {
            return 1;
        }

        idx = (idx + 1) % queue->capacity;
    }

    return 0;
}

int discovered_nodes_init(discovered_nodes_queue_t *queue, size_t capacity) {
    if (!queue || capacity == 0) {
        return -1;
    }

    memset(queue, 0, sizeof(*queue));

    queue->nodes = calloc(capacity, sizeof(discovered_node_t));
    if (!queue->nodes) {
        log_msg(LOG_ERROR, "Failed to allocate discovered nodes queue");
        return -1;
    }

    queue->capacity = capacity;
    queue->head = 0;
    queue->tail = 0;
    queue->count = 0;

    if (pthread_mutex_init(&queue->mutex, NULL) != 0) {
        log_msg(LOG_ERROR, "Failed to initialize queue mutex");
        free(queue->nodes);
        return -1;
    }

    if (pthread_cond_init(&queue->not_empty, NULL) != 0) {
        log_msg(LOG_ERROR, "Failed to initialize not_empty condition");
        pthread_mutex_destroy(&queue->mutex);
        free(queue->nodes);
        return -1;
    }

    if (pthread_cond_init(&queue->not_full, NULL) != 0) {
        log_msg(LOG_ERROR, "Failed to initialize not_full condition");
        pthread_cond_destroy(&queue->not_empty);
        pthread_mutex_destroy(&queue->mutex);
        free(queue->nodes);
        return -1;
    }

    log_msg(LOG_INFO, "Discovered nodes queue initialized (capacity: %zu)", capacity);
    return 0;
}

void discovered_nodes_cleanup(discovered_nodes_queue_t *queue) {
    if (!queue) {
        return;
    }

    pthread_cond_destroy(&queue->not_full);
    pthread_cond_destroy(&queue->not_empty);
    pthread_mutex_destroy(&queue->mutex);

    if (queue->nodes) {
        free(queue->nodes);
        queue->nodes = NULL;
    }

    log_msg(LOG_INFO, "Discovered nodes queue cleaned up");
}

int discovered_nodes_enqueue(discovered_nodes_queue_t *queue,
                             const unsigned char *node_id,
                             const struct sockaddr *addr,
                             socklen_t addr_len,
                             discovery_source_t source) {
    if (!queue || !node_id || !addr) {
        return -1;
    }

    pthread_mutex_lock(&queue->mutex);

    /* Check for duplicates */
    if (is_duplicate(queue, node_id, addr, addr_len)) {
        queue->duplicates_filtered++;
        pthread_mutex_unlock(&queue->mutex);
        return 0; /* Not an error, just filtered */
    }

    /* Check if queue is full */
    if (queue->count >= queue->capacity) {
        queue->queue_full_drops++;
        pthread_mutex_unlock(&queue->mutex);

        /* Log occasionally */
        if (queue->queue_full_drops % 100 == 1) {
            log_msg(LOG_WARN, "Discovered nodes queue full, dropping nodes (total dropped: %llu)",
                    (unsigned long long)queue->queue_full_drops);
        }
        return -1;
    }

    /* Add node to queue */
    discovered_node_t *node = &queue->nodes[queue->tail];
    memcpy(node->node_id, node_id, 20);
    memcpy(&node->addr, addr, addr_len);
    node->addr_len = addr_len;
    node->discovered_at = time(NULL);
    node->source = source;

    queue->tail = (queue->tail + 1) % queue->capacity;
    queue->count++;
    queue->total_enqueued++;

    /* Signal waiting consumers */
    pthread_cond_signal(&queue->not_empty);
    pthread_mutex_unlock(&queue->mutex);

    return 0;
}

int discovered_nodes_dequeue(discovered_nodes_queue_t *queue,
                             discovered_node_t *node,
                             int timeout_ms) {
    if (!queue || !node) {
        return -1;
    }

    pthread_mutex_lock(&queue->mutex);

    /* Wait for items if queue is empty */
    if (timeout_ms > 0) {
        struct timespec ts;
        clock_gettime(CLOCK_REALTIME, &ts);
        ts.tv_sec += timeout_ms / 1000;
        ts.tv_nsec += (timeout_ms % 1000) * 1000000;
        if (ts.tv_nsec >= 1000000000) {
            ts.tv_sec++;
            ts.tv_nsec -= 1000000000;
        }

        while (queue->count == 0) {
            int ret = pthread_cond_timedwait(&queue->not_empty, &queue->mutex, &ts);
            if (ret == ETIMEDOUT) {
                pthread_mutex_unlock(&queue->mutex);
                return -1;
            }
        }
    } else if (queue->count == 0) {
        pthread_mutex_unlock(&queue->mutex);
        return -1;
    }

    /* Remove node from queue */
    memcpy(node, &queue->nodes[queue->head], sizeof(discovered_node_t));
    queue->head = (queue->head + 1) % queue->capacity;
    queue->count--;
    queue->total_dequeued++;

    /* Signal waiting producers */
    pthread_cond_signal(&queue->not_full);
    pthread_mutex_unlock(&queue->mutex);

    return 0;
}

int discovered_nodes_dequeue_batch(discovered_nodes_queue_t *queue,
                                   discovered_node_t *nodes,
                                   size_t max_nodes,
                                   int timeout_ms) {
    if (!queue || !nodes || max_nodes == 0) {
        return -1;
    }

    pthread_mutex_lock(&queue->mutex);

    /* Wait for at least one item if queue is empty */
    if (timeout_ms > 0 && queue->count == 0) {
        struct timespec ts;
        clock_gettime(CLOCK_REALTIME, &ts);
        ts.tv_sec += timeout_ms / 1000;
        ts.tv_nsec += (timeout_ms % 1000) * 1000000;
        if (ts.tv_nsec >= 1000000000) {
            ts.tv_sec++;
            ts.tv_nsec -= 1000000000;
        }

        while (queue->count == 0) {
            int ret = pthread_cond_timedwait(&queue->not_empty, &queue->mutex, &ts);
            if (ret == ETIMEDOUT) {
                pthread_mutex_unlock(&queue->mutex);
                return 0;
            }
        }
    }

    /* Dequeue as many as possible up to max_nodes */
    size_t dequeued = 0;
    while (dequeued < max_nodes && queue->count > 0) {
        memcpy(&nodes[dequeued], &queue->nodes[queue->head], sizeof(discovered_node_t));
        queue->head = (queue->head + 1) % queue->capacity;
        queue->count--;
        queue->total_dequeued++;
        dequeued++;
    }

    /* Signal waiting producers */
    if (dequeued > 0) {
        pthread_cond_broadcast(&queue->not_full);
    }

    pthread_mutex_unlock(&queue->mutex);
    return dequeued;
}

size_t discovered_nodes_count(discovered_nodes_queue_t *queue) {
    if (!queue) {
        return 0;
    }

    pthread_mutex_lock(&queue->mutex);
    size_t count = queue->count;
    pthread_mutex_unlock(&queue->mutex);

    return count;
}

int discovered_nodes_is_empty(discovered_nodes_queue_t *queue) {
    return discovered_nodes_count(queue) == 0;
}

int discovered_nodes_is_full(discovered_nodes_queue_t *queue) {
    if (!queue) {
        return 0;
    }

    pthread_mutex_lock(&queue->mutex);
    int full = (queue->count >= queue->capacity);
    pthread_mutex_unlock(&queue->mutex);

    return full;
}

void discovered_nodes_print_stats(discovered_nodes_queue_t *queue) {
    if (!queue) {
        return;
    }

    pthread_mutex_lock(&queue->mutex);

    log_msg(LOG_INFO, "Discovered Nodes Queue Stats:");
    log_msg(LOG_INFO, "  Current depth: %zu/%zu (%.1f%% full)",
            queue->count, queue->capacity,
            queue->capacity > 0 ? (100.0 * queue->count / queue->capacity) : 0.0);
    log_msg(LOG_INFO, "  Total enqueued: %llu", (unsigned long long)queue->total_enqueued);
    log_msg(LOG_INFO, "  Total dequeued: %llu", (unsigned long long)queue->total_dequeued);
    log_msg(LOG_INFO, "  Duplicates filtered: %llu", (unsigned long long)queue->duplicates_filtered);
    log_msg(LOG_INFO, "  Queue full drops: %llu", (unsigned long long)queue->queue_full_drops);

    pthread_mutex_unlock(&queue->mutex);
}
